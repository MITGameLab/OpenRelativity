// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Prevent NaN and Inf
#define divByZeroCutoff 1e-8f

struct GlobalParams {
	float4x4 ltwMatrix; //local-to-world transform matrix
	float4x4 wtlMatrix; //world-to-local transform matrix
	//float3 piw; //position of object in world
	float4 viw; //velocity of object in synchronous coordinates
	//float3 aviw; //angular velocity of object in inverse local scale
	float4 vpc; //velocity of player
	float4 playerOffset; //player position in world
	//float gtt; // 00 component of metric, due to player acceleration
	float speed; //speed of player;
	float spdOfLight; //current speed of light
	//float wrldTime; //current time in world
	//float strtTime; //starting time in world
	float4x4 metric;
	float4 aiw; //acceleration of object in world coordinates
};

//struct VertDraw {
//	float3 vert;
//	float draw;
//};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
StructuredBuffer<GlobalParams> glblPrms;
RWStructuredBuffer<float3> verts;
//RWStructuredBuffer<float> drawBools;

[numthreads(256, 1, 1)]
//[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4x4 ltwMatrix = glblPrms[0].ltwMatrix;
	float4x4 wtlMatrix = glblPrms[0].wtlMatrix;
	//float3 piw = glblPrms[0].piw;
	float4 viw = glblPrms[0].viw;
	//float3 aviw = glblPrms[0].aviw;
	float4 vpc = glblPrms[0].vpc;
	float4 playerOffset = glblPrms[0].playerOffset;
	//float gtt = glblPrms[0].gtt;
	float speed = glblPrms[0].speed;
	float spdOfLight = glblPrms[0].spdOfLight;
	//float wrldTime = glblPrms[0].wrldTime;
	//float strtTime = glblPrms[0].strtTime;
	float4x4 metric = glblPrms[0].metric;
	float4 aiw = glblPrms[0].aiw;

	float4 pos = float4(verts[id.x].xyz - playerOffset.xyz, 0);

	float vuDot = dot(vpc.xyz, viw.xyz); //Get player velocity dotted with velocity of the object.
	float4 vr;
	//IF our speed is zero, this parallel velocity component will be NaN, so we have a check here just to be safe
	if (speed > divByZeroCutoff)
	{
		float3 uparra = (vuDot / (speed*speed)) * vpc.xyz; //Get the parallel component of the object's velocity
														   //Get the perpendicular component of our velocity, just by subtraction
		float3 uperp = viw.xyz - uparra.xyz;
		//relative velocity calculation
		vr = float4((vpc.xyz - uparra.xyz - (sqrt(1 - speed*speed))*uperp.xyz) / (1 + vuDot), 0);
	}
	//If our speed is nearly zero, it could lead to infinities.
	else
	{
		//relative velocity calculation
		vr = float4(-viw.xyz, 0);
	}
	vr *= -1;

	//riw = location in world, for reference
	float4 riw = float4(pos.xyz, 0); //Position that will be used in the output
	float4 viwScaled = spdOfLight * viw;

	//Here begins a rotation-free modification of the original OpenRelativity shader:

	float c = dot(riw, mul(metric, riw)); //first get position squared (position dotted with position)

	float b = -(2 * dot(riw, mul(metric, viwScaled))); //next get position dotted with velocity, should be only in the Z direction

	float d = spdOfLight * spdOfLight;

	float tisw = 0;
	if ((b * b) >= 4.0 * d * c)
	{
		tisw = (-b - (sqrt((b * b) - 4.0f * d * c))) / (2 * d);
	}

	//get the new position offset, based on the new time we just found
	float4 apparentAccel = float4(aiw.xyz * (1.0f - aiw.w / spdOfLight), 0);
	riw += tisw * float4(viwScaled.xyz, 0) + (apparentAccel * abs(tisw) * tisw / 2.0f);

	//Apply Lorentz transform
	// float newz =(riw.z + state.PlayerVelocity * tisw) / state.SqrtOneMinusVSquaredCWDividedByCSquared;
	//I had to break it up into steps, unity was getting order of operations wrong.	
	float newz = speed * spdOfLight * tisw;

	if (speed > divByZeroCutoff) {
		float3 vpcUnit = vpc.xyz / speed;
		newz = (dot(riw.xyz, vpcUnit) + newz) / (float)sqrt(1 - (speed * speed));
		riw += (newz - dot(riw.xyz, vpcUnit)) * float4(vpcUnit, 0);
	}
	riw += float4(playerOffset.xyz, 0);

	verts[id.x] = riw.xyz;
}
