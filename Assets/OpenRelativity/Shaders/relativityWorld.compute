// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Prevent NaN and Inf
#define divByZeroCutoff 1e-8f

struct GlobalParams {
	float4x4 ltwMatrix; //local-to-world transform matrix
	float4x4 wtlMatrix; //world-to-local transform matrix
	//float3 piw; //position of object in world
	float4 viw; //velocity of object in world
	//float3 aviw; //angular velocity of object in inverse local scale
	float3 vpc; //velocity of player
	float3 playerOffset; //player position in world
	//float gtt; // 00 component of metric, due to player acceleration
	float speed; //speed of player;
	float spdOfLight; //current speed of light
	//float wrldTime; //current time in world
	//float strtTime; //starting time in world
	float4x4 metric;
};

//struct VertDraw {
//	float3 vert;
//	float draw;
//};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
StructuredBuffer<GlobalParams> glblPrms;
RWStructuredBuffer<float3> verts;
//RWStructuredBuffer<float> drawBools;

[numthreads(256, 1, 1)]
//[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4x4 ltwMatrix = glblPrms[0].ltwMatrix;
	float4x4 wtlMatrix = glblPrms[0].wtlMatrix;
	//float3 piw = glblPrms[0].piw;
	float4 viw = glblPrms[0].viw;
	//float3 aviw = glblPrms[0].aviw;
	float3 vpc = glblPrms[0].vpc;
	float3 playerOffset = glblPrms[0].playerOffset;
	//float gtt = glblPrms[0].gtt;
	float speed = glblPrms[0].speed;
	float spdOfLight = glblPrms[0].spdOfLight;
	//float wrldTime = glblPrms[0].wrldTime;
	//float strtTime = glblPrms[0].strtTime;
	float4x4 metric = glblPrms[0].metric;

	float3 pos = verts[id.x] - playerOffset;

	float vuDot = dot(vpc, viw); //Get player velocity dotted with velocity of the object.
	float3 vr;
	//IF our speed is zero, this parallel velocity component will be NaN, so we have a check here just to be safe
	if (speed > divByZeroCutoff)
	{
		float3 uparra = (vuDot / (speed*speed)) * vpc; //Get the parallel component of the object's velocity
		//Get the perpendicular component of our velocity, just by subtraction
		float3 uperp = viw - uparra;
		//relative velocity calculation
		vr = (vpc - uparra - (sqrt(1 - speed*speed))*uperp) / (1 + vuDot);
	}
	//If our speed is nearly zero, it could lead to infinities.
	else
	{
		//relative velocity calculation
		vr = -viw;
	}

	//relative speed
	float speedr = sqrt(dot(vr, vr));

	//riw = location in world, for reference
	float4 riw = float4(pos, 0); //Position that will be used in the output
	float4 viwScaled = spdOfLight * viw;
	float4 viwSpatial = float4(viwScaled.xyz, 0);

	//Transform fails and is unecessary if relative speed is zero:
	if (speedr > divByZeroCutoff)
	{
		//Here begins a rotation-free modification of the original OpenRelativity shader:

		float c = dot(riw, mul(metric, riw)); //first get position squared (position doted with position)

		float b = -(2 * dot(riw, mul(metric, viwSpatial))); //next get position doted with velocity, should be only in the Z direction

		float d = metric._m33 + dot(viwScaled, mul(metric, viwSpatial));

		float tisw = 0;
		if ((b * b) >= 4.0 * d * c)
		{
			tisw = (-b - (sqrt((b * b) - 4.0f * d * c))) / (2 * d);
		}

		//get the new position offset, based on the new time we just found

		riw += (tisw * viwSpatial);

		//Apply Lorentz transform
		//I had to break it up into steps, unity was getting order of operations wrong.	
		float newz = (((float)speed*spdOfLight) * tisw);

		if (speed > divByZeroCutoff) {
			float4 vpcUnit = float4(vpc, 0) / speed;
			newz = (dot(riw, vpcUnit) + newz) / (float)sqrt(1 - (speed*speed));
			riw = riw + (newz - dot(riw, vpcUnit)) * vpcUnit;
		}
	}

	riw += float4(playerOffset, 0);

	//Transform the vertex back into local space for the mesh to use it
	//tempPos = mul(wtlMatrix, float4(riw.x, riw.y, riw.z, 1.0f));
	//verts[id.x] = float3(tempPos.x, tempPos.y, tempPos.z) / tempPos.w;
	verts[id.x] = riw.xyz;
}
