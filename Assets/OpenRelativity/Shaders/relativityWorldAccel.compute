// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Prevent NaN and Inf
#define divByZeroCutoff 1e-8f

struct GlobalParams {
	float4x4 ltwMatrix; //local-to-world transform matrix
	float4x4 wtlMatrix; //world-to-local transform matrix
	float4 viw; //velocity of object in synchronous coordinates
	float4 vpc; //velocity of player
	float4 playerOffset; //player position in world
	float speed; //speed of player;
	float spdOfLight; //current speed of light
	float4x4 mixedMetric;
	float4 apw; //acceleration of player in world coordinates
	float4 avp; //angular velocity of player in world coordinates
};

//struct VertDraw {
//	float3 vert;
//	float draw;
//};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
StructuredBuffer<GlobalParams> glblPrms;
RWStructuredBuffer<float3> verts;
//RWStructuredBuffer<float> drawBools;

[numthreads(256, 1, 1)]
//[numthreads(64,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float4x4 ltwMatrix = glblPrms[0].ltwMatrix;
	float4x4 wtlMatrix = glblPrms[0].wtlMatrix;
	float4 viw = glblPrms[0].viw;
	float4 vpc = glblPrms[0].vpc;
	float4 playerOffset = glblPrms[0].playerOffset;
	float speed = glblPrms[0].speed;
	float spdOfLight = glblPrms[0].spdOfLight;
	float4x4 mixedMetric = glblPrms[0].mixedMetric;
	float4 apw = glblPrms[0].apw;
	float4 avp = glblPrms[0].avp;

	float4 pos = float4(verts[id.x].xyz - playerOffset.xyz, 0);

	//riw = location in world, for reference
	float4 riw = float4(pos.xyz, 0); //Position that will be used in the output

									 //Find metric based on player acceleration:
	float4 angFac = -2 * float4(cross(avp.xyz, riw.xyz), 0) / (spdOfLight * spdOfLight);
	float linFac = dot(apw.xyz, riw.xyz) / (spdOfLight * spdOfLight);
	linFac = (((1 + linFac) * (1 + linFac) - length(angFac)) * spdOfLight * spdOfLight);
	angFac *= spdOfLight;

	float4x4 metric = {
		-1, 0, 0, angFac.x,
		0, -1, 0, angFac.y,
		0, 0, -1, angFac.z,
		angFac.x, angFac.y, angFac.z, linFac
	};

	//Apply conformal map:
	metric = mul(mixedMetric, metric);

	float4 viwScaled = spdOfLight * viw;

	//Here begins a rotation-free modification of the original OpenRelativity shader:

	float c = dot(riw, mul(metric, riw)); //first get position squared (position dotted with position)

	float b = -(2 * dot(riw, mul(metric, viwScaled))); //next get position dotted with velocity, should be only in the Z direction

	float d = spdOfLight * spdOfLight;

	float tisw = 0;
	if ((b * b) >= 4.0 * d * c)
	{
		tisw = (-b - (sqrt((b * b) - 4.0f * d * c))) / (2 * d);
	}

	//get the new position offset, based on the new time we just found
	riw += tisw * viwScaled;

	//Apply Lorentz transform
	// float newz =(riw.z + state.PlayerVelocity * tisw) / state.SqrtOneMinusVSquaredCWDividedByCSquared;
	//I had to break it up into steps, unity was getting order of operations wrong.	
	float newz = speed * spdOfLight * tisw;

	if (speed > divByZeroCutoff) {
		float3 vpcUnit = vpc.xyz / speed;
		newz = (dot(riw.xyz, vpcUnit) + newz) / (float)sqrt(1 - (speed * speed));
		riw += (newz - dot(riw.xyz, vpcUnit)) * float4(vpcUnit, 0);
	}
	riw += float4(playerOffset.xyz, 0);

	verts[id.x] = riw.xyz;
}
