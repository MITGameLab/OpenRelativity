// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Prevent NaN and Inf
#define divByZeroCutoff 1e-8f

//#define quaternion float4
//
//inline quaternion fromToRotation(float3 from, float3 to) {
//	quaternion rotation;
//	rotation.xyz = cross(from, to);
//	rotation.w = sqrt(dot(from, from) + dot(to, to) + dot(from, to));
//	return normalize(rotation);
//}
//
////See: https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/
//inline float3 rotate(quaternion rot, float3 vec) {
//	float3 temp;
//	temp = 2 * cross(rot.xyz, vec.xyz);
//	return vec + rot.w * temp + cross(rot.xyz, temp);
//}
//
//inline quaternion inverse(quaternion q) {
//	return quaternion(-q.xyz, q.w) / length(q);
//}

struct GlobalParams {
	float4x4 ltwMatrix; //local-to-world transform matrix
	float4x4 wtlMatrix; //world-to-local transform matrix
	float4 viw; //velocity of object in synchronous coordinates
	float4 vpc; //velocity of player
	float4 playerOffset; //player position in world
	float speed; //speed of player;
	float spdOfLight; //current speed of light
	float4x4 mixedMetric;
	float4 apw; //acceleration of player in world coordinates
	float4 avp; //angular velocity of player in world coordinates
	float4 aiw; //acceleration of object in world coordinates
};

StructuredBuffer<GlobalParams> glblPrms;
RWStructuredBuffer<float3> verts;

[numthreads(256, 1, 1)]
//[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4x4 ltwMatrix = glblPrms[0].ltwMatrix;
	float4x4 wtlMatrix = glblPrms[0].wtlMatrix;
	float4 viw = glblPrms[0].viw;
	float4 vpc = glblPrms[0].vpc;
	float4 playerOffset = glblPrms[0].playerOffset;
	float speed = glblPrms[0].speed;
	float spdOfLight = glblPrms[0].spdOfLight;
	float4x4 mixedMetric = glblPrms[0].mixedMetric;
	float4 apw = glblPrms[0].apw;
	float4 avp = glblPrms[0].avp;
	float4 aiw = glblPrms[0].aiw;

	float spdOfLightSqrd = spdOfLight * spdOfLight;

	float4 pos = float4(verts[id.x].xyz, 0);
	float4 tempPos = mul(ltwMatrix, float4(pos.xyz, 1.0f));
	pos = float4(tempPos.xyz / tempPos.w - playerOffset.xyz, 0);

	//riw = location in world, for reference
	float4 riw = float4(pos.xyz, 0); //Position that will be used in the output

	//Boost to rest frame of player:
	float beta = speed;
	float gamma = 1.0f / sqrt(1 - beta * beta);
	float4x4 vpcLorentzMatrix = {
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	};
	if (beta > 0)
	{
		float4 vpcTransUnit = float4(vpc.xyz / beta, 1);
		float4 spatialComp = float4((gamma - 1) * vpcTransUnit.xyz, -gamma * beta);
		float4 tComp = -gamma * float4(beta, beta, beta, -1) * vpcTransUnit;
		vpcLorentzMatrix._m30_m31_m32_m33 = tComp;
		vpcLorentzMatrix._m00_m01_m02_m03 = vpcTransUnit.x * spatialComp;
		vpcLorentzMatrix._m10_m11_m12_m13 = vpcTransUnit.y * spatialComp;
		vpcLorentzMatrix._m20_m21_m22_m23 = vpcTransUnit.z * spatialComp;
		vpcLorentzMatrix._m00_m11_m22 += float3(1, 1, 1);
	}

	float4 riwForMetric = mul(vpcLorentzMatrix, riw);

	//Find metric based on player acceleration and rest frame:
	float3 angFac = cross(avp.xyz, riwForMetric.xyz) / spdOfLight;
	float linFac = dot(apw.xyz, riwForMetric.xyz) / spdOfLightSqrd;
	linFac = ((1 + linFac) * (1 + linFac) - dot(angFac, angFac)) * spdOfLightSqrd;
	angFac *= -2;

	float4x4 metric = {
		-1, 0, 0, angFac.x,
		0, -1, 0, angFac.y,
		0, 0, -1, angFac.z,
		angFac.x, angFac.y, angFac.z, linFac
	};

	//Lorentz boost back to world frame;
	float4 transComp = vpcLorentzMatrix._m30_m31_m32_m33;
	transComp.w = -(transComp.w);
	vpcLorentzMatrix._m30_m31_m32_m33 = -transComp;
	vpcLorentzMatrix._m03_m13_m23_m33 = -transComp;
	metric = mul(transpose(vpcLorentzMatrix), mul(metric, vpcLorentzMatrix));

	//Apply conformal map:
	metric = mul(mixedMetric, metric);

	//We'll also Lorentz transform the vectors:
	beta = length(viw.xyz);
	gamma = 1.0f / sqrt(1 - beta * beta);
	float4x4 lorentzMatrix = {
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	};
	if (beta > 0)
	{
		float4 vpcTransUnit = float4(vpc.xyz / beta, 1);
		float4 spatialComp = float4((gamma - 1) * vpcTransUnit.xyz, -gamma * beta);
		float4 tComp = -gamma * float4(beta, beta, beta, -1) * vpcTransUnit;
		vpcLorentzMatrix._m30_m31_m32_m33 = tComp;
		vpcLorentzMatrix._m00_m01_m02_m03 = vpcTransUnit.x * spatialComp;
		vpcLorentzMatrix._m10_m11_m12_m13 = vpcTransUnit.y * spatialComp;
		vpcLorentzMatrix._m20_m21_m22_m23 = vpcTransUnit.z * spatialComp;
		vpcLorentzMatrix._m00_m11_m22 += float3(1, 1, 1);
	}

	//Apply Lorentz transform;
	//metric = mul(transpose(lorentzMatrix), mul(metric, lorentzMatrix));
	float4 riwTransformed = mul(lorentzMatrix, riw);
	float4 avpTransformed = mul(lorentzMatrix, avp);
	float4 aiwTransformed = mul(lorentzMatrix, aiw);

	//We need these values:
	float tisw = riwTransformed.w;
	riwTransformed.w = 0;
	aiwTransformed.w = 0;
	float riwDotRiw = -dot(riwTransformed, mul(metric, riwTransformed));
	float aiwDotAiw = -dot(aiwTransformed, mul(metric, aiwTransformed));
	float riwDotAiw = -dot(riwTransformed, mul(metric, aiwTransformed));

	float sqrtArg = riwDotRiw * (spdOfLightSqrd - riwDotAiw + aiwDotAiw * riwDotRiw / (4 * spdOfLightSqrd)) / ((spdOfLightSqrd - riwDotAiw) * (spdOfLightSqrd - riwDotAiw));
	float t2 = 0;
	if (sqrtArg > 0)
	{
		t2 = -sqrt(sqrtArg);
	}
	float aiwMag = length(aiwTransformed);
	//add the position offset due to acceleration
	if (aiwMag > divByZeroCutoff) {
		riwTransformed.xyz -= aiwTransformed.xyz / aiwMag * spdOfLightSqrd * (sqrt(1 + (aiwMag * t2 / spdOfLight) * (aiwMag * t2 / spdOfLight)) - 1);
	}
	tisw += t2;
	riwTransformed.w = tisw;
	//Inverse Lorentz transform the position:
	lorentzMatrix._m23_m32 = -lorentzMatrix._m23_m32;
	riw = mul(lorentzMatrix, riwTransformed);
	tisw = riw.w;
	riw = float4(riw.xyz + tisw * spdOfLight * viw.xyz, 0);

	//Apply player Lorentz transform
	// float newz =(riw.z + state.PlayerVelocity * tisw) / state.SqrtOneMinusVSquaredCWDividedByCSquared;
	//I had to break it up into steps, unity was getting order of operations wrong.	
	float newz = speed * spdOfLight * tisw;

	if (speed > divByZeroCutoff) {
		float3 vpcUnit = vpc.xyz / speed;
		newz = (dot(riw.xyz, vpcUnit) + newz) / (float)sqrt(1 - (speed * speed));
		riw += (newz - dot(riw.xyz, vpcUnit)) * float4(vpcUnit, 0);
	}

	riw += float4(playerOffset.xyz, 0);

	//Transform the vertex back into local space for the mesh to use it
	tempPos = mul(wtlMatrix, float4(riw.xyz, 1.0f));
	verts[id.x] = float3(tempPos.x, tempPos.y, tempPos.z) / tempPos.w;
}
