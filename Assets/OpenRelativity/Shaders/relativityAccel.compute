// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Prevent NaN and Inf
#define divByZeroCutoff 1e-8f

#define quaternion float4

inline quaternion fromToRotation(float3 from, float3 to) {
	quaternion rotation;
	rotation.xyz = cross(from, to);
	rotation.w = sqrt(dot(from, from) + dot(to, to) + dot(from, to));
	return normalize(rotation);
}

//See: https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/
inline float3 rotate(quaternion rot, float3 vec) {
	float3 temp;
	temp = 2 * cross(rot.xyz, vec.xyz);
	return vec + rot.w * temp + cross(rot.xyz, temp);
}

inline quaternion inverse(quaternion q) {
	return quaternion(-q.xyz, q.w) / length(q);
}

struct GlobalParams {
	float4x4 ltwMatrix; //local-to-world transform matrix
	float4x4 wtlMatrix; //world-to-local transform matrix
	float4 viw; //velocity of object in synchronous coordinates
	float4 vpc; //velocity of player
	float4 playerOffset; //player position in world
	float speed; //speed of player;
	float spdOfLight; //current speed of light
	float4x4 mixedMetric;
	float4 apw; //acceleration of player in world coordinates
	float4 avp; //angular velocity of player in world coordinates
	float4 aiw; //acceleration of object in world coordinates
};

StructuredBuffer<GlobalParams> glblPrms;
RWStructuredBuffer<float3> verts;

[numthreads(256, 1, 1)]
//[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4x4 ltwMatrix = glblPrms[0].ltwMatrix;
	float4x4 wtlMatrix = glblPrms[0].wtlMatrix;
	float4 viw = glblPrms[0].viw;
	float4 vpc = glblPrms[0].vpc;
	float4 playerOffset = glblPrms[0].playerOffset;
	float speed = glblPrms[0].speed;
	float spdOfLight = glblPrms[0].spdOfLight;
	float4x4 mixedMetric = glblPrms[0].mixedMetric;
	float4 apw = glblPrms[0].apw;
	float4 avp = glblPrms[0].avp;
	float4 aiw = glblPrms[0].aiw;

	float4 pos = float4(verts[id.x].xyz, 0);
	float4 tempPos = mul(ltwMatrix, float4(pos.xyz, 1.0f));
	pos = float4(tempPos.xyz / tempPos.w - playerOffset.xyz, 0);

	//riw = location in world, for reference
	float4 riw = float4(pos.xyz, 0); //Position that will be used in the output

	//Rotate all our vectors so that velocity is entirely along z direction:
	quaternion viwToZRot = fromToRotation(viw.xyz, float3(0, 0, 1));
	float4 riwTransformed = float4(rotate(viwToZRot, riw.xyz), riw.w);
	float4 avpTransformed = float4(rotate(viwToZRot, avp.xyz), avp.w);
	float4 apwTransformed = float4(rotate(viwToZRot, apw.xyz), apw.w);
	float4 aiwTransformed = float4(rotate(viwToZRot, aiw.xyz), aiw.w);

	//We'll also Lorentz transform the vectors:
	float beta = length(viw.xyz);
	float gamma = 1.0f / sqrt(1 - beta * beta);
	float4x4 lorentzMatrix = {
		gamma, 0, 0, 0,
		0, gamma, 0, 0,
		0, 0, gamma, -gamma * beta,
		0, 0, -gamma * beta, gamma
	};

	//Apply Lorentz transform;
	//metric = mul(transpose(lorentzMatrix), mul(metric, lorentzMatrix));
	riwTransformed = mul(lorentzMatrix, riwTransformed);
	avpTransformed = mul(lorentzMatrix, avpTransformed);
	aiwTransformed = mul(lorentzMatrix, aiwTransformed);

	//Find metric based on player acceleration:
	float4 angFac = -2 * float4(cross(avpTransformed.xyz, riwTransformed.xyz), 0) / (spdOfLight * spdOfLight);
	float linFac = dot(apwTransformed.xyz, riwTransformed.xyz) / (spdOfLight * spdOfLight);
	linFac = (((1 + linFac) * (1 + linFac) - length(angFac)) * spdOfLight * spdOfLight);
	angFac *= spdOfLight;

	float4x4 metric = {
		-1, 0, 0, angFac.x,
		0, -1, 0, angFac.y,
		0, 0, -1, angFac.z,
		angFac.x, angFac.y, angFac.z, linFac
	};

	//Apply conformal map:
	metric = mul(mixedMetric, metric);

	//We need these values:
	float tisw = riwTransformed.w;
	riwTransformed.w = 0;
	aiwTransformed.w = 0;
	float riwDotRiw = -dot(riwTransformed, mul(metric, riwTransformed));
	float aiwDotAiw = -dot(aiwTransformed, mul(metric, aiwTransformed));
	float riwDotAiw = -dot(riwTransformed, mul(metric, aiwTransformed));
	float cSqrdMinusRiwDotAiw = spdOfLight * spdOfLight - riwDotAiw;
	float denom = spdOfLight * spdOfLight * aiwDotAiw;

	float4 viwScaled = spdOfLight * viw;
	if (abs(denom) > divByZeroCutoff) {
		float t2 = sqrt((-2 * riwDotAiw * cSqrdMinusRiwDotAiw
			+ aiwDotAiw * riwDotRiw
			+ 2 * sqrt(cSqrdMinusRiwDotAiw * cSqrdMinusRiwDotAiw * (riwDotAiw * riwDotAiw + aiwDotAiw * riwDotRiw)))
			/ denom);
		float aiwMag = length(aiwTransformed);
		//add the position offset due to acceleration
		riwTransformed -= aiwTransformed / aiwMag * spdOfLight * spdOfLight * (sqrt(1 + (aiwMag * t2 / spdOfLight) * (aiwMag * t2 / spdOfLight)) - 1);
		tisw += t2;
	}
	else {
		tisw -= sqrt(4.0f * riwDotRiw) / (2 * spdOfLight);
	}
	riwTransformed.w = tisw;
	//Inverse Lorentz transform the position:
	lorentzMatrix._m23_m32 = -lorentzMatrix._m23_m32;
	riwTransformed = mul(lorentzMatrix, riwTransformed);
	riw = float4(rotate(inverse(viwToZRot), riwTransformed.xyz), 0);
	tisw = riwTransformed.w;
	riw.xyz += tisw * viwScaled.xyz;

	//Apply player Lorentz transform
	// float newz =(riw.z + state.PlayerVelocity * tisw) / state.SqrtOneMinusVSquaredCWDividedByCSquared;
	//I had to break it up into steps, unity was getting order of operations wrong.	
	float newz = speed * spdOfLight * tisw;

	if (speed > divByZeroCutoff) {
		float3 vpcUnit = vpc.xyz / speed;
		newz = (dot(riw.xyz, vpcUnit) + newz) / (float)sqrt(1 - (speed * speed));
		riw += (newz - dot(riw.xyz, vpcUnit)) * float4(vpcUnit, 0);
	}

	riw += float4(playerOffset.xyz, 0);

	//Transform the vertex back into local space for the mesh to use it
	tempPos = mul(wtlMatrix, float4(riw.xyz, 1.0f));
	verts[id.x] = float3(tempPos.x, tempPos.y, tempPos.z) / tempPos.w;
}
